
Chapter 2

In fact, excpet for a small number of operators called special forms, the core
of Lisp is a collection of Lisp functions.

What does it mean to say that Lisp provides them as a data type? It means that
in Lisp we can do with functions all the things we expect to do with more
familiar data type, like integers: create new ones at runtime, store them in
variables and in structures, pass them as arguments to other functions, and
return them as results.

Those defuns are not just procedure definitions, they're Lisp calls.

A Common Lisp function is a first-class object, with all the same rights as more
familiar objects like numbers and strings.

A lambda-expression is a list with three parts: the symbol lambda, a parameter
list, and a body of zero or more expressions.

In Common Lisp, we can have a function named double and a variable named double
at the same time.

Beneath the surface, defun is setting the symbol-function of its first argument
to a function constructed from the remaining arguments. The following two
expressions do approximately the same thing:

    (defun double (x) (* x 2))
    (setf (symbol-function 'double)
        #' (lambda (x) (* x 2)))

(me: these expressions below are equivalent)

    (+ 1 2)
    (apply #' + '(1 2))
    (apply (symbol-function '+) '(1 2))
    (apply #' (lambda (x y) (+ x y)) '(1 2))

Writing new utilities which take functional arguments is an important element of
bottom-up programming.

(me: we can associate a function to a symbol as its property, to achieve
 callback function)

In a dynamically scoped Lisp, to find the value of a free variable when
executing scope-test(me: a sample function name), we look back through the chain
of functions that called it.

Closures are functions with local state.

With one important reservation, labels could be described as a sort of let for
functions. (me: section Local functions describes lables)

    (defun count-instances (obj lsts)
        (labels ((instances-in (lst)
                    (if (consp lst)
                        (+ (if (eq (car lst) obj) 1 0) (instances-in (cdr lst)))
                        0)))
         (mapcar #' instances-in lsts)))

Such a call is tail-recursive if no work remains to be done in the calling
function afterwards.

Tail-recursion is desirable because many Common Lisp compilers can transform
tail-recursive functions into loops.

Compiled and interpreted functions are both Lisp objects, and behave the same,
 except with respect to compile-function-p.


Chapter 7 (macros)

A function produces results, but a macro produces expressions-which, when
evaluated, produce results.

What happens when we type the macro call (nil! x) into the toplevel? Lisp
notices that nil! is the name of a macro, and

1. builds the expression specified by the definition above, then
2. evaluates that expression in place of the original macro call.

    (defmacro nil! (var)
        (list 'setq var nil))

When backquote alone is affixed to an expression, it behaves just like quote.

A backquoted list is equivalent to a call to list with the elements quoted. That
is,
    `(a b c) is equal to (list 'a 'b 'c)

Within the scope of a backquote, a comma tells Lisp: "turn off the quoting."
    `( a ,b c, d) is equal to (list 'a b 'c d)

An obvious corollary is that commas may not appear outside of a backquoted
expression.

Backquote is usually used for making lists. Any list generated by backquote can
also be generated by using list and regular quotes.

    (defmacro nil! (var)
        `(setq ,var nil))

Comma-at(,@) is a variant of comma. It behaves like comma, with one difference:
instead of merely inserting the value of the expression to which it is affixed,
 as comma does, comma-at splices it. Splicing can be thought of as inserting
 while removing the outermost level of parenthese.

    (setq b '(1 2 3))
    '( a ,b c)  
    '(a ,@b c)

&body parameter is identical to &rest except for its effect on pretty-printing.

Backquote makes macro definitions both easier to write and easier to read. The
last thing to remember about backquote is that it has a life of ite own,
 spearate from its role in macros.

    (defmacro while (test &body body)
        `(do ()
             ((not ,test))
             ,@body))

macroexpand-1 stops after just one step, even if the expansion is still a macro
call. (me: macroexpand will expand all the macros in in a macro)

Destructuring describes the situation where this sort of positional assignment
is done for arbitrary list structure, as well as flat lists like (x y z).

The Common Lisp defmacro allows parameter lists to be arbitrary list structures.

    (defmacro our-dolist ((var list &optional result) &body body)
        `(progn
            (mapc #' (lambda (,var) ,@body)
                    ,list)
            (let ((,var nil))
                ,result)))

    (our-dolist (x '(a b c)) (print x))

The more general approach to writing macros is to think about the sort of
expression you want to be able to use, what you want it to expand into, and then
write the program that will transform the first form into the second.

If you redefine a function, other functions which call it will automatically get
the new version. The same doesn't always hold for macros.

Chapter 9 (Variable Capture) (me: macro name conflict)

Variable capture occurs when macroexpansion causes a name clash: when some
symbols ends up referring to a variable from another context.

Instances of variable capture can be traced to one of two situations: macro
argument capture and free symbol capture.

There is one certain way to avoid macro argument capture: replacing capturable
symbols with gensyms.

Each call to gensym returns a unique, uninterned symbol.

    (defmacro for ((var start stop) &body body)
      (let ((gstop (gensym)))
        `(do ((,var ,start (1+ ,var))
              (,gstop ,stop))
             ((> ,var ,gstop))
            ,@body)))

In writing macros like for, one must remember that the arguments to a macro are
forms, not values.

In Common Lisp function calls, arguments are evaluated left-ro-right.

Incorrect for:

    ; subject to multiple evaluations
    (defmacro for ((var start stop) &body body)
      `(do ((,var ,start (1+ ,var)))
           ((> ,var ,stop))
         ,@body))

    ; incorrect order of evaluation
    (defmacro for ((var start stop) &body body)
      (let ((gstop (gensym)))
        `(do ((,gstop ,stop)
              (,var ,start (1+ ,var)))
            ((> ,var ,gstop))
           ,@body)))

    (let ((x 1))
      (for (i x (setq x 13)) (princ i)))

    ; correct
    (defmacro for ((var start stop) &body body)
      (let ((gstop (gensym)))
        `(do ((,var ,start (1+ ,var))
              (,gstop ,stop))
            ((> ,var ,gstop))
           ,@body)))


As a general rule, expander code shouldn't depend on anything except its
arguments.

Chapter 11 (Classic Macros)

An operator which is to have a body of expressions must usually be defined as a
macro.

    (defmacro our-let (binds &body body)
      `((lambda ,(mapcar #' (lambda (x)
                               (if (consp x) (car x) x))
                  binds)
              ,@body)
          ,@(mapcar #' (lambda (x)
                          (if (consp x) (cadr x) nil))
              binds)))

The name of context-building macros often begin with with-. The most commonly
used macro of this type is probably with-open-file.

    (unwind-protect 
      (progn (princ "What error?")
             (error "this error."))
      (setq x 'b))

The purpose of unwind-protect is to ensure that certain expressions are
evaluated even if execution is interrupted.

