
Chapter 2

In fact, excpet for a small number of operators called special forms, the core
of Lisp is a collection of Lisp functions.

What does it mean to say that Lisp provides them as a data type? It means that
in Lisp we can do with functions all the things we expect to do with more
familiar data type, like integers: create new ones at runtime, store them in
variables and in structures, pass them as arguments to other functions, and
return them as results.

Those defuns are not just procedure definitions, they're Lisp calls.

A Common Lisp function is a first-class object, with all the same rights as more
familiar objects like numbers and strings.

A lambda-expression is a list with three parts: the symbol lambda, a parameter
list, and a body of zero or more expressions.

In Common Lisp, we can have a function named double and a variable named double
at the same time.

Beneath the surface, defun is setting the symbol-function of its first argument
to a function constructed from the remaining arguments. The following two
expressions do approximately the same thing:

    (defun double (x) (* x 2))
    (setf (symbol-function 'double)
        #' (lambda (x) (* x 2)))

(me: these expressions below are equivalent)

    (+ 1 2)
    (apply #' + '(1 2))
    (apply (symbol-function '+) '(1 2))
    (apply #' (lambda (x y) (+ x y)) '(1 2))

Writing new utilities which take functional arguments is an important element of
bottom-up programming.

(me: we can associate a function to a symbol as its property, to achieve
 callback function)

In a dynamically scoped Lisp, to find the value of a free variable when
executing scope-test(me: a sample function name), we look back through the chain
of functions that called it.

Closures are functions with local state.

With one important reservation, labels could be described as a sort of let for
functions. (me: section Local functions describes lables)

    (defun count-instances (obj lsts)
        (labels ((instances-in (lst)
                    (if (consp lst)
                        (+ (if (eq (car lst) obj) 1 0) (instances-in (cdr lst)))
                        0)))
         (mapcar #' instances-in lsts)))

Such a call is tail-recursive if no work remains to be done in the calling
function afterwards.

Tail-recursion is desirable because many Common Lisp compilers can transform
tail-recursive functions into loops.

Compiled and interpreted functions are both Lisp objects, and behave the same,
 except with respect to compile-function-p.


Chapter 7 (macros)

A function produces results, but a macro produces expressions-which, when
evaluated, produce results.

What happens when we type the macro call (nil! x) into the toplevel? Lisp
notices that nil! is the name of a macro, and

1. builds the expression specified by the definition above, then
2. evaluates that expression in place of the original macro call.

    (defmacro nil! (var)
        (list 'setq var nil))

When backquote alone is affixed to an expression, it behaves just like quote.

A backquoted list is equivalent to a call to list with the elements quoted. That
is,
    `(a b c) is equal to (list 'a 'b 'c)

Within the scope of a backquote, a comma tells Lisp: "turn off the quoting."
    `( a ,b c, d) is equal to (list 'a b 'c d)

An obvious corollary is that commas may not appear outside of a backquoted
expression.

Backquote is usually used for making lists. Any list generated by backquote can
also be generated by using list and regular quotes.

    (defmacro nil! (var)
        `(setq ,var nil))

Comma-at(,@) is a variant of comma. It behaves like comma, with one difference:
instead of merely inserting the value of the expression to which it is affixed,
 as comma does, comma-at splices it. Splicing can be thought of as inserting
 while removing the outermost level of parenthese.

    (setq b '(1 2 3))
    '( a ,b c)  
    '(a ,@b c)

&body parameter is identical to &rest except for its effect on pretty-printing.

Backquote makes macro definitions both easier to write and easier to read. The
last thing to remember about backquote is that it has a life of ite own,
 spearate from its role in macros.

    (defmacro while (test &body body)
        `(do ()
             ((not ,test))
             ,@body))

macroexpand-1 stops after just one step, even if the expansion is still a macro
call. (me: macroexpand will expand all the macros in in a macro)

Destructuring describes the situation where this sort of positional assignment
is done for arbitrary list structure, as well as flat lists like (x y z).

The Common Lisp defmacro allows parameter lists to be arbitrary list structures.

    (defmacro our-dolist ((var list &optional result) &body body)
        `(progn
            (mapc #' (lambda (,var) ,@body)
                    ,list)
            (let ((,var nil))
                ,result)))

    (our-dolist (x '(a b c)) (print x))

The more general approach to writing macros is to think about the sort of
expression you want to be able to use, what you want it to expand into, and then
write the program that will transform the first form into the second.

If you redefine a function, other functions which call it will automatically get
the new version. The same doesn't always hold for macros.


