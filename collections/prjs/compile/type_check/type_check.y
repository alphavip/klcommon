%{
/* kevin lynx 3.27.2010 */
#include <stdio.h>
#include "sym_table.h"

extern int yylex();/*generated by flex */ 
extern char *yytext;
#define NAME_S (64)
/* identifier name stack, the name[NAME_S] is a temp place */
char name[NAME_S+2][256];
/* name stack position */
int name_p = 0;
/* struct declarator count */
int decl_c = 0;
%}
%union {
	int type;
	char *name;
}
/* yacc will generate these constant */
%token <type> CHAR INT SHORT FLOAT DOUBLE
%token STRUCT 
%token <name> IDENTIFIER
%type <type> type_specifier
%type <type> basic_type
%type <type> struct_specifier
%type <name> init_declarator_list
%type <name> identifier
%%
declaration_list
	: declaration
	| declaration_list declaration
	;
declaration
	: type_specifier init_declarator_list ';' { 
			while( name_p > 0 )
			{
				--name_p;
				if( $1 >= 0 )
				{
					int t = sym_type( name[name_p] );
					if( t >= 0 )
					{
						char err[256];
						sprintf( err, "symbol %s(%s) already exists",
							name[name_p], type_get_desc( t ) );						
						yyerror( err );
					}
					else
					{
						sym_add( name[name_p], $1 );
					}
				} /* if */
			} /* while */
	}
	;

type_specifier
	: basic_type 
	| struct_specifier
	;

basic_type
	: CHAR { $$ = type_get_id( yytext ); }
	| SHORT { $$ = type_get_id( yytext ); }
	| INT { $$ = type_get_id( yytext ); }
	| FLOAT { $$ = type_get_id( yytext ); }
	| DOUBLE { $$ = type_get_id( yytext ); }
	;

struct_specifier
	: STRUCT identifier {
				/* must save the struct name here */
				strcpy( name[NAME_S+1], $2 );
	}	
	'{' struct_declaration_list '}' { 
				/* register a struct type */
				$$ = type_register_struct( name[NAME_S+1] );
	} 
	| STRUCT '{' struct_declaration_list '}' {
				/* register a anonymous struct type */
				$$ = type_register_anon();
	}
	| STRUCT identifier {
				/* lookup the type id */
				const char *s = $2;
				int i = type_get_id( s );
				if( i < 0 ) 
				{
					char err[256] = "undefined type ";
					strcat( err, s );
					yyerror( err );
				}
				$$ = i;
	}
	;

struct_declaration_list
	: struct_declaration
	| struct_declaration_list struct_declaration
	;

struct_declaration
	: type_specifier struct_declarator_list ';' { 
				/* ignore the struct member name */ 
				name_p -= decl_c; 
				decl_c = 0;
	}
	;

struct_declarator_list
	: identifier { add_struct_decl( $1 ); }
	| struct_declarator_list ',' identifier { add_struct_decl( $3 ); }
	;

identifier
	: IDENTIFIER { 
				/* save the identifier here */
				strcpy( name[NAME_S], yytext ); $$ = name[NAME_S];
	}
	;

init_declarator_list
	: identifier { add_name( $1 ); }
   	| init_declarator_list ',' identifier {  add_name( $3 ); }
	;
%%
void yyerror( const char *s )
{
	fprintf( stderr, "yyerror: %s\n", s );
}

void add_name( const char *str )
{
	strcpy( name[name_p++], str );
}

void add_struct_decl( const char *str )
{
	decl_c++;
	add_name( str );
}

int main()
{
	type_init();
	yyparse();
	printf( "---------------------------------------------\n" );
	type_dump();
	printf( "---------------------------------------------\n" );
	sym_dump();
	type_release();
	sym_clear();
	return 0;
}

